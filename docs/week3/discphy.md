# 5주차 프로세스와 쓰레드

## 프로세스와 쓰레드 

+ 프로세스 : 운영체제로부터 자원을 할당받는 작업의 단위
+ 쓰레드 : 프로세스가 할당받은 자원을 이용하는 실행의 단위
 
## 프로세스 구조 

+ Code : Java main과 같은 코드 
+ Data : 프로그램이 실행중 저장 할 수 있는 저장공간을 의미 (전역변수, 정적변수, 배열 등)
+ Memory : 
  + Stack : 지역변수, 매개변수 리턴 변수를 저장하는 공간 
  + Heap : 프로그램이 동적으로 필요한 변수를 저장하는 공간 (new() 등)

## 쓰레드 

+ 쓰레드는 프로세스내에서 일하는 일꾼이다.

## 싱글 쓰레드 

+ 프로세스 안에서 하나의 쓰레드만 실행디는 것만을 말함

## 멀티 쓰레드

+ 프로세스 안에서 여러개의 쓰레드가 실행되는 것을 말함
+ 동기화 문제가 생길 수 있음 
+ 교착상태(데드락)이 발생할 수 있다.

> "걸리는 시간이나, 동작을 예측할 수가 없다..!!"

## 데몬 쓰레드 

+ 우선순위가 낮아, 리소스를 적게 할당받는다. 
+ 보조적인 역할을 담당하며, 대표적으로 가비지 컬렉터가 있다.

## 사용자 쓰레드

+ 높은 우선순위를 가지는 쓰레드
+ 프로그램 기능을 담당하며, 대표적으로 메인 쓰레드가 있다.

**JVM은 사용자 쓰레드의 작업이 끝나면, 데몬 쓰레드도 자동으로 종료시켜 버린다.**

## join 

+ 밀리세컨드를 지정하지 않으면 쓰레드가 동작이 완료될 때까지 기다린다. 

## synchronized

+ 한 쓰레드가 진행중인 작업을 다른 쓰레두가 침범하지 못하도록 막는 것을 쓰레드 동기화(synchronized)라고 합니다.
+ 동기화를 하려면 다른 쓰레드의 침범을 막아야하는 코드들을 **임계영역**으로 설정하면 됩니다. 
+ 임계영역에는 Lock을 가진 단 하나의 쓰레드만 출입이 가능합니다.
+ 즉 임계영역은 한번에 한 쓰레드만 사용이 가능합니다.

## Lock 

### ReentrantLock 

+ 재진입 가능한 Lock, 가장 일반적인 배타 Lock
+ 특정 조건에서 Lock을 풀고, 나중에 다시 Lock을 얻어 임계영역으로 진입이 가능
+ ReentrantLock을 사용하면, 같은 스레드가 이미 락을 가지고 있더라도 락을 유지하며 계속 실행할 수 있기 때문에 데드락이 발생하지 않습니다.
+ 즉, ReentrantLcodk을 사용하면 코드의 유연성을 높일 수 있습니다.

### ReentrantReadWriteLock

+ 읽기를 위한 Lock과 쓰기를 위한 Lock을 따로 제공합니다. 
+ 읽기에는 공유적이고, 쓰기에는 베타적인 Lock입니다.
+ 읽기 Lock이 걸려있으면 다른 쓰레드들도 읽기 Lock을 중복으로 걸고 읽기를 수행할 수 있습니다. (read-only)
+ 읽기 Lock이 걸려있는 상태에서 쓰기 Lock을 거는 것은 허용되지 않습니다. (데이터 변경 방지)

### StampedLock

+ ReentrantReadWriteLock에 낙관적인 Lock의 기능을 추가
  + 낙관적인 Lock : 데이터를 변경하기 전에 락을 걸지 않는 것, 데이터 변경을 할 때 충돌이 일어날 가능성이 적은 상황에서 사용합니다. 
  + 낙관적인 락을 사용하면 읽기와 쓰기 작업 모두가 빠르게 처리. 
  + 쓰기 작업이 발생했을 때 데이터가 이미 변경된 경우 다시 읽기 작업을 수행하여 새로운 값을 읽어들이고, 변경 작업을 다시 수행
  + 쓰기 작업이 빈번하지 않은 경우 적합
+ 낙관적인 읽기 Lock은 쓰기 Lock에 의해 바로 해제 가능    
+ 무조건 읽기 Lock을 걸지 않고, 쓰기와 읽기가 충돌할 때만 쓰기 후 읽기 Lock을 건다.

## Condition

wait()와 notify()는 waiting pool내에 대기중인 스레드를 구분하지 못함.  
그래서 Condition 인터페이스 등장, wait()와 notify() 대신 await(), signal()을 사용한다.





